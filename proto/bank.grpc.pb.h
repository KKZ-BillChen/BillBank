// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bank.proto
// Original file comments:
// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#ifndef GRPC_bank_2eproto__INCLUDED
#define GRPC_bank_2eproto__INCLUDED

#include "bank.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace bank {

// The greeting service definition.
class Greeter final {
 public:
  static constexpr char const* service_full_name() {
    return "bank.Greeter";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Sends a greeting
    virtual ::grpc::Status SayHello(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::bank::HelloReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::HelloReply>> AsyncSayHello(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::HelloReply>>(AsyncSayHelloRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::HelloReply>> PrepareAsyncSayHello(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::HelloReply>>(PrepareAsyncSayHelloRaw(context, request, cq));
    }
    // Create account
    virtual ::grpc::Status CreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::bank::CreateAccountReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::CreateAccountReply>> AsyncCreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::CreateAccountReply>>(AsyncCreateAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::CreateAccountReply>> PrepareAsyncCreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::CreateAccountReply>>(PrepareAsyncCreateAccountRaw(context, request, cq));
    }
    // Close account
    virtual ::grpc::Status CloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncCloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncCloseAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncCloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncCloseAccountRaw(context, request, cq));
    }
    // Show account
    virtual ::grpc::Status ShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::ShowAccountReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::ShowAccountReply>> AsyncShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::ShowAccountReply>>(AsyncShowAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::ShowAccountReply>> PrepareAsyncShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::ShowAccountReply>>(PrepareAsyncShowAccountRaw(context, request, cq));
    }
    // User Login
    virtual ::grpc::Status UserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::bank::LoginReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>> AsyncUserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>>(AsyncUserLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>> PrepareAsyncUserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>>(PrepareAsyncUserLoginRaw(context, request, cq));
    }
    // Manager Login
    virtual ::grpc::Status ManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::bank::LoginReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>> AsyncManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>>(AsyncManagerLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>> PrepareAsyncManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>>(PrepareAsyncManagerLoginRaw(context, request, cq));
    }
    // Change Password
    virtual ::grpc::Status ChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncChangePasswordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncChangePasswordRaw(context, request, cq));
    }
    // User Deposit
    // User Demand Deposit
    virtual ::grpc::Status UserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncUserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncUserDemandDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncUserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncUserDemandDepositRaw(context, request, cq));
    }
    // User Saving Deposit
    virtual ::grpc::Status UserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncUserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncUserSavingDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncUserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncUserSavingDepositRaw(context, request, cq));
    }
    // User Withdraw
    // User Demand Withdraw
    virtual ::grpc::Status UserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncUserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncUserDemandWithdrawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncUserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncUserDemandWithdrawRaw(context, request, cq));
    }
    // User Saving Withdraw
    virtual ::grpc::Status UserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncUserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncUserSavingWithdrawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncUserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncUserSavingWithdrawRaw(context, request, cq));
    }
    // User Transfer
    virtual ::grpc::Status UserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncUserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncUserTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncUserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncUserTransferRaw(context, request, cq));
    }
    // User Loan
    virtual ::grpc::Status UserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncUserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncUserLoanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncUserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncUserLoanRaw(context, request, cq));
    }
    // User Loan Pay
    virtual ::grpc::Status UserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncUserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncUserLoanPayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncUserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncUserLoanPayRaw(context, request, cq));
    }
    // Manager Lock User
    virtual ::grpc::Status LockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncLockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncLockUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncLockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncLockUserRaw(context, request, cq));
    }
    // Manager Unlock User
    virtual ::grpc::Status UnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncUnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncUnlockUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncUnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncUnlockUserRaw(context, request, cq));
    }
    // All Account Basic List
    virtual ::grpc::Status AllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::bank::AllAccountsBasicStatusReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsBasicStatusReply>> AsyncAllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsBasicStatusReply>>(AsyncAllAccountsBasicStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsBasicStatusReply>> PrepareAsyncAllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsBasicStatusReply>>(PrepareAsyncAllAccountsBasicStatusRaw(context, request, cq));
    }
    // All Account Saving Document
    virtual ::grpc::Status AllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::bank::AllAccountsSavingDocumentReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsSavingDocumentReply>> AsyncAllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsSavingDocumentReply>>(AsyncAllAccountsSavingDocumentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsSavingDocumentReply>> PrepareAsyncAllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsSavingDocumentReply>>(PrepareAsyncAllAccountsSavingDocumentRaw(context, request, cq));
    }
    // Manager Detials Change
    virtual ::grpc::Status ChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::bank::SimpleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> AsyncChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(AsyncChangeManagerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>> PrepareAsyncChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>>(PrepareAsyncChangeManagerRaw(context, request, cq));
    }
    // Exit Client
    virtual ::grpc::Status Exit(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::bank::EmptyReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::EmptyReply>> AsyncExit(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::EmptyReply>>(AsyncExitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::EmptyReply>> PrepareAsyncExit(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::EmptyReply>>(PrepareAsyncExitRaw(context, request, cq));
    }
    // Judge Locked
    virtual ::grpc::Status JudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::LockedReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LockedReply>> AsyncJudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LockedReply>>(AsyncJudgeLockedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LockedReply>> PrepareAsyncJudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bank::LockedReply>>(PrepareAsyncJudgeLockedRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Sends a greeting
      virtual void SayHello(::grpc::ClientContext* context, const ::bank::HelloRequest* request, ::bank::HelloReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SayHello(::grpc::ClientContext* context, const ::bank::HelloRequest* request, ::bank::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SayHello(::grpc::ClientContext* context, const ::bank::HelloRequest* request, ::bank::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Create account
      virtual void CreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest* request, ::bank::CreateAccountReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest* request, ::bank::CreateAccountReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest* request, ::bank::CreateAccountReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Close account
      virtual void CloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Show account
      virtual void ShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::ShowAccountReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::ShowAccountReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::ShowAccountReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // User Login
      virtual void UserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Manager Login
      virtual void ManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Change Password
      virtual void ChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // User Deposit
      // User Demand Deposit
      virtual void UserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // User Saving Deposit
      virtual void UserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // User Withdraw
      // User Demand Withdraw
      virtual void UserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // User Saving Withdraw
      virtual void UserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // User Transfer
      virtual void UserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // User Loan
      virtual void UserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // User Loan Pay
      virtual void UserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Manager Lock User
      virtual void LockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Manager Unlock User
      virtual void UnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // All Account Basic List
      virtual void AllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsBasicStatusReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsBasicStatusReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsBasicStatusReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // All Account Saving Document
      virtual void AllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsSavingDocumentReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsSavingDocumentReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsSavingDocumentReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Manager Detials Change
      virtual void ChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Exit Client
      virtual void Exit(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::EmptyReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Exit(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::EmptyReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Exit(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::EmptyReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Judge Locked
      virtual void JudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::LockedReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void JudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::LockedReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void JudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::LockedReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::HelloReply>* AsyncSayHelloRaw(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::HelloReply>* PrepareAsyncSayHelloRaw(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::CreateAccountReply>* AsyncCreateAccountRaw(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::CreateAccountReply>* PrepareAsyncCreateAccountRaw(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncCloseAccountRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncCloseAccountRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::ShowAccountReply>* AsyncShowAccountRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::ShowAccountReply>* PrepareAsyncShowAccountRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>* AsyncUserLoginRaw(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>* PrepareAsyncUserLoginRaw(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>* AsyncManagerLoginRaw(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::LoginReply>* PrepareAsyncManagerLoginRaw(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncChangePasswordRaw(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncChangePasswordRaw(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncUserDemandDepositRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncUserDemandDepositRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncUserSavingDepositRaw(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncUserSavingDepositRaw(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncUserDemandWithdrawRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncUserDemandWithdrawRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncUserSavingWithdrawRaw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncUserSavingWithdrawRaw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncUserTransferRaw(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncUserTransferRaw(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncUserLoanRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncUserLoanRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncUserLoanPayRaw(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncUserLoanPayRaw(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncLockUserRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncLockUserRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncUnlockUserRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncUnlockUserRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsBasicStatusReply>* AsyncAllAccountsBasicStatusRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsBasicStatusReply>* PrepareAsyncAllAccountsBasicStatusRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsSavingDocumentReply>* AsyncAllAccountsSavingDocumentRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::AllAccountsSavingDocumentReply>* PrepareAsyncAllAccountsSavingDocumentRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* AsyncChangeManagerRaw(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::SimpleReply>* PrepareAsyncChangeManagerRaw(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::EmptyReply>* AsyncExitRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::EmptyReply>* PrepareAsyncExitRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::LockedReply>* AsyncJudgeLockedRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bank::LockedReply>* PrepareAsyncJudgeLockedRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SayHello(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::bank::HelloReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::HelloReply>> AsyncSayHello(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::HelloReply>>(AsyncSayHelloRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::HelloReply>> PrepareAsyncSayHello(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::HelloReply>>(PrepareAsyncSayHelloRaw(context, request, cq));
    }
    ::grpc::Status CreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::bank::CreateAccountReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::CreateAccountReply>> AsyncCreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::CreateAccountReply>>(AsyncCreateAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::CreateAccountReply>> PrepareAsyncCreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::CreateAccountReply>>(PrepareAsyncCreateAccountRaw(context, request, cq));
    }
    ::grpc::Status CloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncCloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncCloseAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncCloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncCloseAccountRaw(context, request, cq));
    }
    ::grpc::Status ShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::ShowAccountReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::ShowAccountReply>> AsyncShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::ShowAccountReply>>(AsyncShowAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::ShowAccountReply>> PrepareAsyncShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::ShowAccountReply>>(PrepareAsyncShowAccountRaw(context, request, cq));
    }
    ::grpc::Status UserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::bank::LoginReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>> AsyncUserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>>(AsyncUserLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>> PrepareAsyncUserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>>(PrepareAsyncUserLoginRaw(context, request, cq));
    }
    ::grpc::Status ManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::bank::LoginReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>> AsyncManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>>(AsyncManagerLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>> PrepareAsyncManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>>(PrepareAsyncManagerLoginRaw(context, request, cq));
    }
    ::grpc::Status ChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncChangePasswordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncChangePasswordRaw(context, request, cq));
    }
    ::grpc::Status UserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncUserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncUserDemandDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncUserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncUserDemandDepositRaw(context, request, cq));
    }
    ::grpc::Status UserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncUserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncUserSavingDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncUserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncUserSavingDepositRaw(context, request, cq));
    }
    ::grpc::Status UserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncUserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncUserDemandWithdrawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncUserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncUserDemandWithdrawRaw(context, request, cq));
    }
    ::grpc::Status UserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncUserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncUserSavingWithdrawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncUserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncUserSavingWithdrawRaw(context, request, cq));
    }
    ::grpc::Status UserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncUserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncUserTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncUserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncUserTransferRaw(context, request, cq));
    }
    ::grpc::Status UserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncUserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncUserLoanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncUserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncUserLoanRaw(context, request, cq));
    }
    ::grpc::Status UserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncUserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncUserLoanPayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncUserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncUserLoanPayRaw(context, request, cq));
    }
    ::grpc::Status LockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncLockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncLockUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncLockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncLockUserRaw(context, request, cq));
    }
    ::grpc::Status UnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncUnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncUnlockUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncUnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncUnlockUserRaw(context, request, cq));
    }
    ::grpc::Status AllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::bank::AllAccountsBasicStatusReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsBasicStatusReply>> AsyncAllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsBasicStatusReply>>(AsyncAllAccountsBasicStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsBasicStatusReply>> PrepareAsyncAllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsBasicStatusReply>>(PrepareAsyncAllAccountsBasicStatusRaw(context, request, cq));
    }
    ::grpc::Status AllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::bank::AllAccountsSavingDocumentReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsSavingDocumentReply>> AsyncAllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsSavingDocumentReply>>(AsyncAllAccountsSavingDocumentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsSavingDocumentReply>> PrepareAsyncAllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsSavingDocumentReply>>(PrepareAsyncAllAccountsSavingDocumentRaw(context, request, cq));
    }
    ::grpc::Status ChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::bank::SimpleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> AsyncChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(AsyncChangeManagerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>> PrepareAsyncChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>>(PrepareAsyncChangeManagerRaw(context, request, cq));
    }
    ::grpc::Status Exit(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::bank::EmptyReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::EmptyReply>> AsyncExit(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::EmptyReply>>(AsyncExitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::EmptyReply>> PrepareAsyncExit(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::EmptyReply>>(PrepareAsyncExitRaw(context, request, cq));
    }
    ::grpc::Status JudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::bank::LockedReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LockedReply>> AsyncJudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LockedReply>>(AsyncJudgeLockedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LockedReply>> PrepareAsyncJudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bank::LockedReply>>(PrepareAsyncJudgeLockedRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SayHello(::grpc::ClientContext* context, const ::bank::HelloRequest* request, ::bank::HelloReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SayHello(::grpc::ClientContext* context, const ::bank::HelloRequest* request, ::bank::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SayHello(::grpc::ClientContext* context, const ::bank::HelloRequest* request, ::bank::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest* request, ::bank::CreateAccountReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest* request, ::bank::CreateAccountReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateAccount(::grpc::ClientContext* context, const ::bank::CreateAccountRequest* request, ::bank::CreateAccountReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CloseAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::ShowAccountReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::ShowAccountReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ShowAccount(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::ShowAccountReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UserLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ManagerLogin(::grpc::ClientContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ChangePassword(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UserDemandDeposit(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UserSavingDeposit(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UserDemandWithdraw(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UserSavingWithdraw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UserTransfer(::grpc::ClientContext* context, const ::bank::UserTransferRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UserLoan(::grpc::ClientContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UserLoanPay(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlockUser(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsBasicStatusReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsBasicStatusReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AllAccountsBasicStatus(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsBasicStatusReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsSavingDocumentReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsSavingDocumentReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AllAccountsSavingDocument(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsSavingDocumentReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest* request, ::bank::SimpleReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest* request, ::bank::SimpleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ChangeManager(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest* request, ::bank::SimpleReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Exit(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::EmptyReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Exit(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::EmptyReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Exit(::grpc::ClientContext* context, const ::bank::EmptyRequest* request, ::bank::EmptyReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void JudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::LockedReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void JudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::LockedReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void JudgeLocked(::grpc::ClientContext* context, const ::bank::SimpleRequest* request, ::bank::LockedReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bank::HelloReply>* AsyncSayHelloRaw(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::HelloReply>* PrepareAsyncSayHelloRaw(::grpc::ClientContext* context, const ::bank::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::CreateAccountReply>* AsyncCreateAccountRaw(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::CreateAccountReply>* PrepareAsyncCreateAccountRaw(::grpc::ClientContext* context, const ::bank::CreateAccountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncCloseAccountRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncCloseAccountRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::ShowAccountReply>* AsyncShowAccountRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::ShowAccountReply>* PrepareAsyncShowAccountRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>* AsyncUserLoginRaw(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>* PrepareAsyncUserLoginRaw(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>* AsyncManagerLoginRaw(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::LoginReply>* PrepareAsyncManagerLoginRaw(::grpc::ClientContext* context, const ::bank::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncChangePasswordRaw(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncChangePasswordRaw(::grpc::ClientContext* context, const ::bank::ChangePasswordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncUserDemandDepositRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncUserDemandDepositRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncUserSavingDepositRaw(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncUserSavingDepositRaw(::grpc::ClientContext* context, const ::bank::UserSavingDepositRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncUserDemandWithdrawRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncUserDemandWithdrawRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncUserSavingWithdrawRaw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncUserSavingWithdrawRaw(::grpc::ClientContext* context, const ::bank::UserSavingWithdrawRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncUserTransferRaw(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncUserTransferRaw(::grpc::ClientContext* context, const ::bank::UserTransferRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncUserLoanRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncUserLoanRaw(::grpc::ClientContext* context, const ::bank::UserDemandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncUserLoanPayRaw(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncUserLoanPayRaw(::grpc::ClientContext* context, const ::bank::UserLoanPayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncLockUserRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncLockUserRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncUnlockUserRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncUnlockUserRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsBasicStatusReply>* AsyncAllAccountsBasicStatusRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsBasicStatusReply>* PrepareAsyncAllAccountsBasicStatusRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsSavingDocumentReply>* AsyncAllAccountsSavingDocumentRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::AllAccountsSavingDocumentReply>* PrepareAsyncAllAccountsSavingDocumentRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* AsyncChangeManagerRaw(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::SimpleReply>* PrepareAsyncChangeManagerRaw(::grpc::ClientContext* context, const ::bank::ChangeManagerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::EmptyReply>* AsyncExitRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::EmptyReply>* PrepareAsyncExitRaw(::grpc::ClientContext* context, const ::bank::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::LockedReply>* AsyncJudgeLockedRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bank::LockedReply>* PrepareAsyncJudgeLockedRaw(::grpc::ClientContext* context, const ::bank::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SayHello_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_CloseAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_ShowAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_UserLogin_;
    const ::grpc::internal::RpcMethod rpcmethod_ManagerLogin_;
    const ::grpc::internal::RpcMethod rpcmethod_ChangePassword_;
    const ::grpc::internal::RpcMethod rpcmethod_UserDemandDeposit_;
    const ::grpc::internal::RpcMethod rpcmethod_UserSavingDeposit_;
    const ::grpc::internal::RpcMethod rpcmethod_UserDemandWithdraw_;
    const ::grpc::internal::RpcMethod rpcmethod_UserSavingWithdraw_;
    const ::grpc::internal::RpcMethod rpcmethod_UserTransfer_;
    const ::grpc::internal::RpcMethod rpcmethod_UserLoan_;
    const ::grpc::internal::RpcMethod rpcmethod_UserLoanPay_;
    const ::grpc::internal::RpcMethod rpcmethod_LockUser_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlockUser_;
    const ::grpc::internal::RpcMethod rpcmethod_AllAccountsBasicStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_AllAccountsSavingDocument_;
    const ::grpc::internal::RpcMethod rpcmethod_ChangeManager_;
    const ::grpc::internal::RpcMethod rpcmethod_Exit_;
    const ::grpc::internal::RpcMethod rpcmethod_JudgeLocked_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Sends a greeting
    virtual ::grpc::Status SayHello(::grpc::ServerContext* context, const ::bank::HelloRequest* request, ::bank::HelloReply* response);
    // Create account
    virtual ::grpc::Status CreateAccount(::grpc::ServerContext* context, const ::bank::CreateAccountRequest* request, ::bank::CreateAccountReply* response);
    // Close account
    virtual ::grpc::Status CloseAccount(::grpc::ServerContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response);
    // Show account
    virtual ::grpc::Status ShowAccount(::grpc::ServerContext* context, const ::bank::SimpleRequest* request, ::bank::ShowAccountReply* response);
    // User Login
    virtual ::grpc::Status UserLogin(::grpc::ServerContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response);
    // Manager Login
    virtual ::grpc::Status ManagerLogin(::grpc::ServerContext* context, const ::bank::LoginRequest* request, ::bank::LoginReply* response);
    // Change Password
    virtual ::grpc::Status ChangePassword(::grpc::ServerContext* context, const ::bank::ChangePasswordRequest* request, ::bank::SimpleReply* response);
    // User Deposit
    // User Demand Deposit
    virtual ::grpc::Status UserDemandDeposit(::grpc::ServerContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response);
    // User Saving Deposit
    virtual ::grpc::Status UserSavingDeposit(::grpc::ServerContext* context, const ::bank::UserSavingDepositRequest* request, ::bank::SimpleReply* response);
    // User Withdraw
    // User Demand Withdraw
    virtual ::grpc::Status UserDemandWithdraw(::grpc::ServerContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response);
    // User Saving Withdraw
    virtual ::grpc::Status UserSavingWithdraw(::grpc::ServerContext* context, const ::bank::UserSavingWithdrawRequest* request, ::bank::SimpleReply* response);
    // User Transfer
    virtual ::grpc::Status UserTransfer(::grpc::ServerContext* context, const ::bank::UserTransferRequest* request, ::bank::SimpleReply* response);
    // User Loan
    virtual ::grpc::Status UserLoan(::grpc::ServerContext* context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response);
    // User Loan Pay
    virtual ::grpc::Status UserLoanPay(::grpc::ServerContext* context, const ::bank::UserLoanPayRequest* request, ::bank::SimpleReply* response);
    // Manager Lock User
    virtual ::grpc::Status LockUser(::grpc::ServerContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response);
    // Manager Unlock User
    virtual ::grpc::Status UnlockUser(::grpc::ServerContext* context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response);
    // All Account Basic List
    virtual ::grpc::Status AllAccountsBasicStatus(::grpc::ServerContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsBasicStatusReply* response);
    // All Account Saving Document
    virtual ::grpc::Status AllAccountsSavingDocument(::grpc::ServerContext* context, const ::bank::EmptyRequest* request, ::bank::AllAccountsSavingDocumentReply* response);
    // Manager Detials Change
    virtual ::grpc::Status ChangeManager(::grpc::ServerContext* context, const ::bank::ChangeManagerRequest* request, ::bank::SimpleReply* response);
    // Exit Client
    virtual ::grpc::Status Exit(::grpc::ServerContext* context, const ::bank::EmptyRequest* request, ::bank::EmptyReply* response);
    // Judge Locked
    virtual ::grpc::Status JudgeLocked(::grpc::ServerContext* context, const ::bank::SimpleRequest* request, ::bank::LockedReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SayHello() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::bank::HelloRequest* /*request*/, ::bank::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSayHello(::grpc::ServerContext* context, ::bank::HelloRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::HelloReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateAccount() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CreateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAccount(::grpc::ServerContext* /*context*/, const ::bank::CreateAccountRequest* /*request*/, ::bank::CreateAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateAccount(::grpc::ServerContext* context, ::bank::CreateAccountRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::CreateAccountReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CloseAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CloseAccount() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_CloseAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCloseAccount(::grpc::ServerContext* context, ::bank::SimpleRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ShowAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ShowAccount() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ShowAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::ShowAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShowAccount(::grpc::ServerContext* context, ::bank::SimpleRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::ShowAccountReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UserLogin() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_UserLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserLogin(::grpc::ServerContext* context, ::bank::LoginRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::LoginReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ManagerLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ManagerLogin() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ManagerLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManagerLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestManagerLogin(::grpc::ServerContext* context, ::bank::LoginRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::LoginReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChangePassword() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::bank::ChangePasswordRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangePassword(::grpc::ServerContext* context, ::bank::ChangePasswordRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserDemandDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UserDemandDeposit() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_UserDemandDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserDemandDeposit(::grpc::ServerContext* context, ::bank::UserDemandRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserSavingDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UserSavingDeposit() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_UserSavingDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserSavingDepositRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserSavingDeposit(::grpc::ServerContext* context, ::bank::UserSavingDepositRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserDemandWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UserDemandWithdraw() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_UserDemandWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserDemandWithdraw(::grpc::ServerContext* context, ::bank::UserDemandRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserSavingWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UserSavingWithdraw() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_UserSavingWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserSavingWithdrawRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserSavingWithdraw(::grpc::ServerContext* context, ::bank::UserSavingWithdrawRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UserTransfer() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_UserTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserTransfer(::grpc::ServerContext* /*context*/, const ::bank::UserTransferRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserTransfer(::grpc::ServerContext* context, ::bank::UserTransferRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserLoan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UserLoan() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_UserLoan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoan(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserLoan(::grpc::ServerContext* context, ::bank::UserDemandRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UserLoanPay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UserLoanPay() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_UserLoanPay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoanPay(::grpc::ServerContext* /*context*/, const ::bank::UserLoanPayRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserLoanPay(::grpc::ServerContext* context, ::bank::UserLoanPayRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LockUser() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_LockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLockUser(::grpc::ServerContext* context, ::bank::SimpleRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlockUser() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_UnlockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlockUser(::grpc::ServerContext* context, ::bank::SimpleRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AllAccountsBasicStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AllAccountsBasicStatus() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_AllAccountsBasicStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsBasicStatus(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsBasicStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAllAccountsBasicStatus(::grpc::ServerContext* context, ::bank::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::AllAccountsBasicStatusReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AllAccountsSavingDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AllAccountsSavingDocument() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_AllAccountsSavingDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsSavingDocument(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsSavingDocumentReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAllAccountsSavingDocument(::grpc::ServerContext* context, ::bank::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::AllAccountsSavingDocumentReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChangeManager : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChangeManager() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_ChangeManager() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeManager(::grpc::ServerContext* /*context*/, const ::bank::ChangeManagerRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangeManager(::grpc::ServerContext* context, ::bank::ChangeManagerRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::SimpleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Exit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Exit() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_Exit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exit(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::EmptyReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExit(::grpc::ServerContext* context, ::bank::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::EmptyReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JudgeLocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JudgeLocked() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_JudgeLocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JudgeLocked(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::LockedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJudgeLocked(::grpc::ServerContext* context, ::bank::SimpleRequest* request, ::grpc::ServerAsyncResponseWriter< ::bank::LockedReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SayHello<WithAsyncMethod_CreateAccount<WithAsyncMethod_CloseAccount<WithAsyncMethod_ShowAccount<WithAsyncMethod_UserLogin<WithAsyncMethod_ManagerLogin<WithAsyncMethod_ChangePassword<WithAsyncMethod_UserDemandDeposit<WithAsyncMethod_UserSavingDeposit<WithAsyncMethod_UserDemandWithdraw<WithAsyncMethod_UserSavingWithdraw<WithAsyncMethod_UserTransfer<WithAsyncMethod_UserLoan<WithAsyncMethod_UserLoanPay<WithAsyncMethod_LockUser<WithAsyncMethod_UnlockUser<WithAsyncMethod_AllAccountsBasicStatus<WithAsyncMethod_AllAccountsSavingDocument<WithAsyncMethod_ChangeManager<WithAsyncMethod_Exit<WithAsyncMethod_JudgeLocked<Service > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SayHello() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::HelloRequest, ::bank::HelloReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::HelloRequest* request, ::bank::HelloReply* response) { return this->SayHello(context, request, response); }));}
    void SetMessageAllocatorFor_SayHello(
        ::grpc::experimental::MessageAllocator< ::bank::HelloRequest, ::bank::HelloReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::HelloRequest, ::bank::HelloReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::bank::HelloRequest* /*request*/, ::bank::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SayHello(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::HelloRequest* /*request*/, ::bank::HelloReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SayHello(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::HelloRequest* /*request*/, ::bank::HelloReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::CreateAccountRequest, ::bank::CreateAccountReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::CreateAccountRequest* request, ::bank::CreateAccountReply* response) { return this->CreateAccount(context, request, response); }));}
    void SetMessageAllocatorFor_CreateAccount(
        ::grpc::experimental::MessageAllocator< ::bank::CreateAccountRequest, ::bank::CreateAccountReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::CreateAccountRequest, ::bank::CreateAccountReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAccount(::grpc::ServerContext* /*context*/, const ::bank::CreateAccountRequest* /*request*/, ::bank::CreateAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::CreateAccountRequest* /*request*/, ::bank::CreateAccountReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::CreateAccountRequest* /*request*/, ::bank::CreateAccountReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CloseAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CloseAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response) { return this->CloseAccount(context, request, response); }));}
    void SetMessageAllocatorFor_CloseAccount(
        ::grpc::experimental::MessageAllocator< ::bank::SimpleRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CloseAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CloseAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CloseAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ShowAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ShowAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::ShowAccountReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::SimpleRequest* request, ::bank::ShowAccountReply* response) { return this->ShowAccount(context, request, response); }));}
    void SetMessageAllocatorFor_ShowAccount(
        ::grpc::experimental::MessageAllocator< ::bank::SimpleRequest, ::bank::ShowAccountReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::ShowAccountReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ShowAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::ShowAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ShowAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::ShowAccountReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ShowAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::ShowAccountReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UserLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UserLogin() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::LoginRequest, ::bank::LoginReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::LoginRequest* request, ::bank::LoginReply* response) { return this->UserLogin(context, request, response); }));}
    void SetMessageAllocatorFor_UserLogin(
        ::grpc::experimental::MessageAllocator< ::bank::LoginRequest, ::bank::LoginReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::LoginRequest, ::bank::LoginReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UserLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserLogin(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserLogin(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ManagerLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ManagerLogin() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::LoginRequest, ::bank::LoginReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::LoginRequest* request, ::bank::LoginReply* response) { return this->ManagerLogin(context, request, response); }));}
    void SetMessageAllocatorFor_ManagerLogin(
        ::grpc::experimental::MessageAllocator< ::bank::LoginRequest, ::bank::LoginReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::LoginRequest, ::bank::LoginReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ManagerLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManagerLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ManagerLogin(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ManagerLogin(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChangePassword() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::ChangePasswordRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::ChangePasswordRequest* request, ::bank::SimpleReply* response) { return this->ChangePassword(context, request, response); }));}
    void SetMessageAllocatorFor_ChangePassword(
        ::grpc::experimental::MessageAllocator< ::bank::ChangePasswordRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::ChangePasswordRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::bank::ChangePasswordRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangePassword(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::ChangePasswordRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangePassword(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::ChangePasswordRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UserDemandDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UserDemandDeposit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::UserDemandRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response) { return this->UserDemandDeposit(context, request, response); }));}
    void SetMessageAllocatorFor_UserDemandDeposit(
        ::grpc::experimental::MessageAllocator< ::bank::UserDemandRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::UserDemandRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UserDemandDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserDemandDeposit(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserDemandDeposit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UserSavingDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UserSavingDeposit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::UserSavingDepositRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::UserSavingDepositRequest* request, ::bank::SimpleReply* response) { return this->UserSavingDeposit(context, request, response); }));}
    void SetMessageAllocatorFor_UserSavingDeposit(
        ::grpc::experimental::MessageAllocator< ::bank::UserSavingDepositRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::UserSavingDepositRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UserSavingDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserSavingDepositRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserSavingDeposit(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::UserSavingDepositRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserSavingDeposit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::UserSavingDepositRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UserDemandWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UserDemandWithdraw() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::UserDemandRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response) { return this->UserDemandWithdraw(context, request, response); }));}
    void SetMessageAllocatorFor_UserDemandWithdraw(
        ::grpc::experimental::MessageAllocator< ::bank::UserDemandRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::UserDemandRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UserDemandWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserDemandWithdraw(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserDemandWithdraw(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UserSavingWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UserSavingWithdraw() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::UserSavingWithdrawRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::UserSavingWithdrawRequest* request, ::bank::SimpleReply* response) { return this->UserSavingWithdraw(context, request, response); }));}
    void SetMessageAllocatorFor_UserSavingWithdraw(
        ::grpc::experimental::MessageAllocator< ::bank::UserSavingWithdrawRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::UserSavingWithdrawRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UserSavingWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserSavingWithdrawRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserSavingWithdraw(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::UserSavingWithdrawRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserSavingWithdraw(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::UserSavingWithdrawRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UserTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UserTransfer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::UserTransferRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::UserTransferRequest* request, ::bank::SimpleReply* response) { return this->UserTransfer(context, request, response); }));}
    void SetMessageAllocatorFor_UserTransfer(
        ::grpc::experimental::MessageAllocator< ::bank::UserTransferRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::UserTransferRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UserTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserTransfer(::grpc::ServerContext* /*context*/, const ::bank::UserTransferRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::UserTransferRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserTransfer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::UserTransferRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UserLoan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UserLoan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::UserDemandRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::UserDemandRequest* request, ::bank::SimpleReply* response) { return this->UserLoan(context, request, response); }));}
    void SetMessageAllocatorFor_UserLoan(
        ::grpc::experimental::MessageAllocator< ::bank::UserDemandRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::UserDemandRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UserLoan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoan(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserLoan(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserLoan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UserLoanPay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UserLoanPay() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::UserLoanPayRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::UserLoanPayRequest* request, ::bank::SimpleReply* response) { return this->UserLoanPay(context, request, response); }));}
    void SetMessageAllocatorFor_UserLoanPay(
        ::grpc::experimental::MessageAllocator< ::bank::UserLoanPayRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::UserLoanPayRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UserLoanPay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoanPay(::grpc::ServerContext* /*context*/, const ::bank::UserLoanPayRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserLoanPay(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::UserLoanPayRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserLoanPay(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::UserLoanPayRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LockUser() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response) { return this->LockUser(context, request, response); }));}
    void SetMessageAllocatorFor_LockUser(
        ::grpc::experimental::MessageAllocator< ::bank::SimpleRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LockUser(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LockUser(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlockUser() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::SimpleRequest* request, ::bank::SimpleReply* response) { return this->UnlockUser(context, request, response); }));}
    void SetMessageAllocatorFor_UnlockUser(
        ::grpc::experimental::MessageAllocator< ::bank::SimpleRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlockUser(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlockUser(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AllAccountsBasicStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AllAccountsBasicStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::EmptyRequest, ::bank::AllAccountsBasicStatusReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::EmptyRequest* request, ::bank::AllAccountsBasicStatusReply* response) { return this->AllAccountsBasicStatus(context, request, response); }));}
    void SetMessageAllocatorFor_AllAccountsBasicStatus(
        ::grpc::experimental::MessageAllocator< ::bank::EmptyRequest, ::bank::AllAccountsBasicStatusReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::EmptyRequest, ::bank::AllAccountsBasicStatusReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AllAccountsBasicStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsBasicStatus(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsBasicStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AllAccountsBasicStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsBasicStatusReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AllAccountsBasicStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsBasicStatusReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AllAccountsSavingDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AllAccountsSavingDocument() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::EmptyRequest, ::bank::AllAccountsSavingDocumentReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::EmptyRequest* request, ::bank::AllAccountsSavingDocumentReply* response) { return this->AllAccountsSavingDocument(context, request, response); }));}
    void SetMessageAllocatorFor_AllAccountsSavingDocument(
        ::grpc::experimental::MessageAllocator< ::bank::EmptyRequest, ::bank::AllAccountsSavingDocumentReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::EmptyRequest, ::bank::AllAccountsSavingDocumentReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AllAccountsSavingDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsSavingDocument(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsSavingDocumentReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AllAccountsSavingDocument(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsSavingDocumentReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AllAccountsSavingDocument(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsSavingDocumentReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChangeManager : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChangeManager() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::ChangeManagerRequest, ::bank::SimpleReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::ChangeManagerRequest* request, ::bank::SimpleReply* response) { return this->ChangeManager(context, request, response); }));}
    void SetMessageAllocatorFor_ChangeManager(
        ::grpc::experimental::MessageAllocator< ::bank::ChangeManagerRequest, ::bank::SimpleReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::ChangeManagerRequest, ::bank::SimpleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ChangeManager() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeManager(::grpc::ServerContext* /*context*/, const ::bank::ChangeManagerRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangeManager(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::ChangeManagerRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangeManager(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::ChangeManagerRequest* /*request*/, ::bank::SimpleReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Exit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Exit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::EmptyRequest, ::bank::EmptyReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::EmptyRequest* request, ::bank::EmptyReply* response) { return this->Exit(context, request, response); }));}
    void SetMessageAllocatorFor_Exit(
        ::grpc::experimental::MessageAllocator< ::bank::EmptyRequest, ::bank::EmptyReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::EmptyRequest, ::bank::EmptyReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Exit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exit(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::EmptyReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Exit(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::EmptyReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Exit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::EmptyReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_JudgeLocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_JudgeLocked() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::LockedReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bank::SimpleRequest* request, ::bank::LockedReply* response) { return this->JudgeLocked(context, request, response); }));}
    void SetMessageAllocatorFor_JudgeLocked(
        ::grpc::experimental::MessageAllocator< ::bank::SimpleRequest, ::bank::LockedReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bank::SimpleRequest, ::bank::LockedReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_JudgeLocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JudgeLocked(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::LockedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JudgeLocked(
      ::grpc::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::LockedReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JudgeLocked(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::LockedReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SayHello<ExperimentalWithCallbackMethod_CreateAccount<ExperimentalWithCallbackMethod_CloseAccount<ExperimentalWithCallbackMethod_ShowAccount<ExperimentalWithCallbackMethod_UserLogin<ExperimentalWithCallbackMethod_ManagerLogin<ExperimentalWithCallbackMethod_ChangePassword<ExperimentalWithCallbackMethod_UserDemandDeposit<ExperimentalWithCallbackMethod_UserSavingDeposit<ExperimentalWithCallbackMethod_UserDemandWithdraw<ExperimentalWithCallbackMethod_UserSavingWithdraw<ExperimentalWithCallbackMethod_UserTransfer<ExperimentalWithCallbackMethod_UserLoan<ExperimentalWithCallbackMethod_UserLoanPay<ExperimentalWithCallbackMethod_LockUser<ExperimentalWithCallbackMethod_UnlockUser<ExperimentalWithCallbackMethod_AllAccountsBasicStatus<ExperimentalWithCallbackMethod_AllAccountsSavingDocument<ExperimentalWithCallbackMethod_ChangeManager<ExperimentalWithCallbackMethod_Exit<ExperimentalWithCallbackMethod_JudgeLocked<Service > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SayHello<ExperimentalWithCallbackMethod_CreateAccount<ExperimentalWithCallbackMethod_CloseAccount<ExperimentalWithCallbackMethod_ShowAccount<ExperimentalWithCallbackMethod_UserLogin<ExperimentalWithCallbackMethod_ManagerLogin<ExperimentalWithCallbackMethod_ChangePassword<ExperimentalWithCallbackMethod_UserDemandDeposit<ExperimentalWithCallbackMethod_UserSavingDeposit<ExperimentalWithCallbackMethod_UserDemandWithdraw<ExperimentalWithCallbackMethod_UserSavingWithdraw<ExperimentalWithCallbackMethod_UserTransfer<ExperimentalWithCallbackMethod_UserLoan<ExperimentalWithCallbackMethod_UserLoanPay<ExperimentalWithCallbackMethod_LockUser<ExperimentalWithCallbackMethod_UnlockUser<ExperimentalWithCallbackMethod_AllAccountsBasicStatus<ExperimentalWithCallbackMethod_AllAccountsSavingDocument<ExperimentalWithCallbackMethod_ChangeManager<ExperimentalWithCallbackMethod_Exit<ExperimentalWithCallbackMethod_JudgeLocked<Service > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SayHello() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::bank::HelloRequest* /*request*/, ::bank::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateAccount() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CreateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAccount(::grpc::ServerContext* /*context*/, const ::bank::CreateAccountRequest* /*request*/, ::bank::CreateAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CloseAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CloseAccount() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_CloseAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ShowAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ShowAccount() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ShowAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::ShowAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UserLogin() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_UserLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ManagerLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ManagerLogin() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ManagerLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManagerLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChangePassword() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::bank::ChangePasswordRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserDemandDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UserDemandDeposit() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_UserDemandDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserSavingDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UserSavingDeposit() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_UserSavingDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserSavingDepositRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserDemandWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UserDemandWithdraw() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_UserDemandWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserSavingWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UserSavingWithdraw() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_UserSavingWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserSavingWithdrawRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UserTransfer() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_UserTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserTransfer(::grpc::ServerContext* /*context*/, const ::bank::UserTransferRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserLoan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UserLoan() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_UserLoan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoan(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UserLoanPay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UserLoanPay() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_UserLoanPay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoanPay(::grpc::ServerContext* /*context*/, const ::bank::UserLoanPayRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LockUser() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_LockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlockUser() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_UnlockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AllAccountsBasicStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AllAccountsBasicStatus() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_AllAccountsBasicStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsBasicStatus(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsBasicStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AllAccountsSavingDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AllAccountsSavingDocument() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_AllAccountsSavingDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsSavingDocument(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsSavingDocumentReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChangeManager : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChangeManager() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_ChangeManager() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeManager(::grpc::ServerContext* /*context*/, const ::bank::ChangeManagerRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Exit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Exit() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_Exit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exit(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::EmptyReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JudgeLocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JudgeLocked() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_JudgeLocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JudgeLocked(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::LockedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SayHello() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::bank::HelloRequest* /*request*/, ::bank::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSayHello(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateAccount() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CreateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAccount(::grpc::ServerContext* /*context*/, const ::bank::CreateAccountRequest* /*request*/, ::bank::CreateAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CloseAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CloseAccount() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_CloseAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCloseAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ShowAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ShowAccount() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ShowAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::ShowAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestShowAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UserLogin() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_UserLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ManagerLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ManagerLogin() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ManagerLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManagerLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestManagerLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChangePassword() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::bank::ChangePasswordRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangePassword(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserDemandDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UserDemandDeposit() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_UserDemandDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserDemandDeposit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserSavingDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UserSavingDeposit() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_UserSavingDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserSavingDepositRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserSavingDeposit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserDemandWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UserDemandWithdraw() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_UserDemandWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserDemandWithdraw(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserSavingWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UserSavingWithdraw() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_UserSavingWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserSavingWithdrawRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserSavingWithdraw(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UserTransfer() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_UserTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserTransfer(::grpc::ServerContext* /*context*/, const ::bank::UserTransferRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserTransfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserLoan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UserLoan() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_UserLoan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoan(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserLoan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UserLoanPay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UserLoanPay() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_UserLoanPay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoanPay(::grpc::ServerContext* /*context*/, const ::bank::UserLoanPayRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUserLoanPay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LockUser() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_LockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLockUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlockUser() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_UnlockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlockUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AllAccountsBasicStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AllAccountsBasicStatus() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_AllAccountsBasicStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsBasicStatus(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsBasicStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAllAccountsBasicStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AllAccountsSavingDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AllAccountsSavingDocument() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_AllAccountsSavingDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsSavingDocument(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsSavingDocumentReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAllAccountsSavingDocument(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChangeManager : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChangeManager() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_ChangeManager() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeManager(::grpc::ServerContext* /*context*/, const ::bank::ChangeManagerRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangeManager(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Exit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Exit() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_Exit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exit(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::EmptyReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JudgeLocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JudgeLocked() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_JudgeLocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JudgeLocked(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::LockedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJudgeLocked(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SayHello() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SayHello(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::bank::HelloRequest* /*request*/, ::bank::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SayHello(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SayHello(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAccount(::grpc::ServerContext* /*context*/, const ::bank::CreateAccountRequest* /*request*/, ::bank::CreateAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CloseAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CloseAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CloseAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CloseAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CloseAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CloseAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CloseAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ShowAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ShowAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ShowAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ShowAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ShowAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::ShowAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ShowAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ShowAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UserLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UserLogin() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UserLogin(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UserLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserLogin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserLogin(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ManagerLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ManagerLogin() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ManagerLogin(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ManagerLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManagerLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ManagerLogin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ManagerLogin(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChangePassword() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChangePassword(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::bank::ChangePasswordRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangePassword(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangePassword(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UserDemandDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UserDemandDeposit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UserDemandDeposit(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UserDemandDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserDemandDeposit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserDemandDeposit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UserSavingDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UserSavingDeposit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UserSavingDeposit(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UserSavingDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserSavingDepositRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserSavingDeposit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserSavingDeposit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UserDemandWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UserDemandWithdraw() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UserDemandWithdraw(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UserDemandWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserDemandWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserDemandWithdraw(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserDemandWithdraw(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UserSavingWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UserSavingWithdraw() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UserSavingWithdraw(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UserSavingWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserSavingWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserSavingWithdrawRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserSavingWithdraw(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserSavingWithdraw(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UserTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UserTransfer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UserTransfer(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UserTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserTransfer(::grpc::ServerContext* /*context*/, const ::bank::UserTransferRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserTransfer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UserLoan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UserLoan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UserLoan(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UserLoan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoan(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserLoan(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserLoan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UserLoanPay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UserLoanPay() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UserLoanPay(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UserLoanPay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UserLoanPay(::grpc::ServerContext* /*context*/, const ::bank::UserLoanPayRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UserLoanPay(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UserLoanPay(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LockUser() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LockUser(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LockUser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LockUser(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlockUser() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlockUser(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlockUser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlockUser(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AllAccountsBasicStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AllAccountsBasicStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AllAccountsBasicStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AllAccountsBasicStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsBasicStatus(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsBasicStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AllAccountsBasicStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AllAccountsBasicStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AllAccountsSavingDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AllAccountsSavingDocument() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AllAccountsSavingDocument(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AllAccountsSavingDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllAccountsSavingDocument(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsSavingDocumentReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AllAccountsSavingDocument(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AllAccountsSavingDocument(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChangeManager : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChangeManager() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChangeManager(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChangeManager() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangeManager(::grpc::ServerContext* /*context*/, const ::bank::ChangeManagerRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangeManager(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangeManager(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Exit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Exit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Exit(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Exit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exit(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::EmptyReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Exit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Exit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_JudgeLocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_JudgeLocked() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JudgeLocked(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_JudgeLocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JudgeLocked(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::LockedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JudgeLocked(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JudgeLocked(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SayHello() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::HelloRequest, ::bank::HelloReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::HelloRequest, ::bank::HelloReply>* streamer) {
                       return this->StreamedSayHello(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::bank::HelloRequest* /*request*/, ::bank::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSayHello(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::HelloRequest,::bank::HelloReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateAccount() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::CreateAccountRequest, ::bank::CreateAccountReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::CreateAccountRequest, ::bank::CreateAccountReply>* streamer) {
                       return this->StreamedCreateAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateAccount(::grpc::ServerContext* /*context*/, const ::bank::CreateAccountRequest* /*request*/, ::bank::CreateAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::CreateAccountRequest,::bank::CreateAccountReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CloseAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CloseAccount() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::SimpleRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::SimpleRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedCloseAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CloseAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CloseAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCloseAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::SimpleRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ShowAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ShowAccount() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::SimpleRequest, ::bank::ShowAccountReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::SimpleRequest, ::bank::ShowAccountReply>* streamer) {
                       return this->StreamedShowAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ShowAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ShowAccount(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::ShowAccountReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedShowAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::SimpleRequest,::bank::ShowAccountReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UserLogin() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::LoginRequest, ::bank::LoginReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::LoginRequest, ::bank::LoginReply>* streamer) {
                       return this->StreamedUserLogin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UserLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::LoginRequest,::bank::LoginReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ManagerLogin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ManagerLogin() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::LoginRequest, ::bank::LoginReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::LoginRequest, ::bank::LoginReply>* streamer) {
                       return this->StreamedManagerLogin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ManagerLogin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ManagerLogin(::grpc::ServerContext* /*context*/, const ::bank::LoginRequest* /*request*/, ::bank::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedManagerLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::LoginRequest,::bank::LoginReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChangePassword() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::ChangePasswordRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::ChangePasswordRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedChangePassword(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::bank::ChangePasswordRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChangePassword(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::ChangePasswordRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserDemandDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UserDemandDeposit() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::UserDemandRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::UserDemandRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedUserDemandDeposit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UserDemandDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserDemandDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserDemandDeposit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::UserDemandRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserSavingDeposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UserSavingDeposit() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::UserSavingDepositRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::UserSavingDepositRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedUserSavingDeposit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UserSavingDeposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserSavingDeposit(::grpc::ServerContext* /*context*/, const ::bank::UserSavingDepositRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserSavingDeposit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::UserSavingDepositRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserDemandWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UserDemandWithdraw() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::UserDemandRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::UserDemandRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedUserDemandWithdraw(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UserDemandWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserDemandWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserDemandWithdraw(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::UserDemandRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserSavingWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UserSavingWithdraw() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::UserSavingWithdrawRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::UserSavingWithdrawRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedUserSavingWithdraw(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UserSavingWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserSavingWithdraw(::grpc::ServerContext* /*context*/, const ::bank::UserSavingWithdrawRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserSavingWithdraw(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::UserSavingWithdrawRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UserTransfer() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::UserTransferRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::UserTransferRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedUserTransfer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UserTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserTransfer(::grpc::ServerContext* /*context*/, const ::bank::UserTransferRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserTransfer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::UserTransferRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserLoan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UserLoan() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::UserDemandRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::UserDemandRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedUserLoan(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UserLoan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserLoan(::grpc::ServerContext* /*context*/, const ::bank::UserDemandRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserLoan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::UserDemandRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UserLoanPay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UserLoanPay() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::UserLoanPayRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::UserLoanPayRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedUserLoanPay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UserLoanPay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UserLoanPay(::grpc::ServerContext* /*context*/, const ::bank::UserLoanPayRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUserLoanPay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::UserLoanPayRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LockUser() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::SimpleRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::SimpleRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedLockUser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLockUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::SimpleRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlockUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlockUser() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::SimpleRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::SimpleRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedUnlockUser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlockUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlockUser(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlockUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::SimpleRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AllAccountsBasicStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AllAccountsBasicStatus() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::EmptyRequest, ::bank::AllAccountsBasicStatusReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::EmptyRequest, ::bank::AllAccountsBasicStatusReply>* streamer) {
                       return this->StreamedAllAccountsBasicStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AllAccountsBasicStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AllAccountsBasicStatus(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsBasicStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAllAccountsBasicStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::EmptyRequest,::bank::AllAccountsBasicStatusReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AllAccountsSavingDocument : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AllAccountsSavingDocument() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::EmptyRequest, ::bank::AllAccountsSavingDocumentReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::EmptyRequest, ::bank::AllAccountsSavingDocumentReply>* streamer) {
                       return this->StreamedAllAccountsSavingDocument(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AllAccountsSavingDocument() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AllAccountsSavingDocument(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::AllAccountsSavingDocumentReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAllAccountsSavingDocument(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::EmptyRequest,::bank::AllAccountsSavingDocumentReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChangeManager : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChangeManager() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::ChangeManagerRequest, ::bank::SimpleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::ChangeManagerRequest, ::bank::SimpleReply>* streamer) {
                       return this->StreamedChangeManager(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChangeManager() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChangeManager(::grpc::ServerContext* /*context*/, const ::bank::ChangeManagerRequest* /*request*/, ::bank::SimpleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChangeManager(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::ChangeManagerRequest,::bank::SimpleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Exit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Exit() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::EmptyRequest, ::bank::EmptyReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::EmptyRequest, ::bank::EmptyReply>* streamer) {
                       return this->StreamedExit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Exit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Exit(::grpc::ServerContext* /*context*/, const ::bank::EmptyRequest* /*request*/, ::bank::EmptyReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::EmptyRequest,::bank::EmptyReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JudgeLocked : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JudgeLocked() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bank::SimpleRequest, ::bank::LockedReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bank::SimpleRequest, ::bank::LockedReply>* streamer) {
                       return this->StreamedJudgeLocked(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JudgeLocked() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JudgeLocked(::grpc::ServerContext* /*context*/, const ::bank::SimpleRequest* /*request*/, ::bank::LockedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJudgeLocked(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bank::SimpleRequest,::bank::LockedReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SayHello<WithStreamedUnaryMethod_CreateAccount<WithStreamedUnaryMethod_CloseAccount<WithStreamedUnaryMethod_ShowAccount<WithStreamedUnaryMethod_UserLogin<WithStreamedUnaryMethod_ManagerLogin<WithStreamedUnaryMethod_ChangePassword<WithStreamedUnaryMethod_UserDemandDeposit<WithStreamedUnaryMethod_UserSavingDeposit<WithStreamedUnaryMethod_UserDemandWithdraw<WithStreamedUnaryMethod_UserSavingWithdraw<WithStreamedUnaryMethod_UserTransfer<WithStreamedUnaryMethod_UserLoan<WithStreamedUnaryMethod_UserLoanPay<WithStreamedUnaryMethod_LockUser<WithStreamedUnaryMethod_UnlockUser<WithStreamedUnaryMethod_AllAccountsBasicStatus<WithStreamedUnaryMethod_AllAccountsSavingDocument<WithStreamedUnaryMethod_ChangeManager<WithStreamedUnaryMethod_Exit<WithStreamedUnaryMethod_JudgeLocked<Service > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SayHello<WithStreamedUnaryMethod_CreateAccount<WithStreamedUnaryMethod_CloseAccount<WithStreamedUnaryMethod_ShowAccount<WithStreamedUnaryMethod_UserLogin<WithStreamedUnaryMethod_ManagerLogin<WithStreamedUnaryMethod_ChangePassword<WithStreamedUnaryMethod_UserDemandDeposit<WithStreamedUnaryMethod_UserSavingDeposit<WithStreamedUnaryMethod_UserDemandWithdraw<WithStreamedUnaryMethod_UserSavingWithdraw<WithStreamedUnaryMethod_UserTransfer<WithStreamedUnaryMethod_UserLoan<WithStreamedUnaryMethod_UserLoanPay<WithStreamedUnaryMethod_LockUser<WithStreamedUnaryMethod_UnlockUser<WithStreamedUnaryMethod_AllAccountsBasicStatus<WithStreamedUnaryMethod_AllAccountsSavingDocument<WithStreamedUnaryMethod_ChangeManager<WithStreamedUnaryMethod_Exit<WithStreamedUnaryMethod_JudgeLocked<Service > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace bank


#endif  // GRPC_bank_2eproto__INCLUDED
